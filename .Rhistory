Mu          = numeric(2),
Sigma       = Sigma_new
)
return(-1 * LL)
}
I <- diag(q)
S2par <- coef(fit.SM, type = "free")
S2par
# Second, replicate the Hessian of the parameters of Step 2 (NOT NECESSARY)
obj.S2 <- function(x){
beta <- matrix(data = 0, nrow = q, ncol = q)
beta[1, 2] <- x[1]
psi <- matrix(data = 0, nrow = q, ncol = q)
psi[1, 1] <- x[3]
psi[2, 2] <- x[2]
Sigma_new <- solve(I - beta) %*% psi %*% t(solve(I - beta))
LL <- lavaan:::lav_mvnorm_loglik_samplestats(
sample.mean = numeric(2),
sample.nobs = 301,
sample.cov  = (cov_S1 * 300) / 301,
Mu          = numeric(2),
Sigma       = Sigma_new
)
return(-1 * LL)
}
I <- diag(q)
S2par <- coef(fit.SM, type = "free")
H_2 <- numDeriv::hessian(func = obj.S2, x = S2par)
H_2
round(H_2, 3)
S2par
unclass(S2par)
H_2 <- numDeriv::hessian(func = obj.S2, x = c(0.4215874, 0.9812431, 0.6475562))
H_2
round(H_2, 3)
S2par
obj.S2(x = c(0.4215874, 0.9812431, 0.6475562))
I_22
# (2) Use numDeriv to replicate all parts of the I matrix --------------------------------------------------------------
p <- ncol(Data)
q <- length(lavNames(fit.MM, type = "lv"))
# First, replicate Hessian of the parameters in Step 1
obj.S1 <- function(x){
lambda <- matrix(data = 0, nrow = p, ncol = q)
lambda[1, 1] <- 1; lambda[4, 2] <- 1
lambda[2:3, 1] <- x[1:2]
lambda[5:6, 2] <- x[3:4]
theta <- matrix(data = 0, nrow = p, ncol = p)
diag(theta) <- x[5:10]
psi <- matrix(data = 0, nrow = q, ncol = q)
psi[1, 1] <- x[11]
psi[2, 2] <- x[12]
psi[2, 1] <- psi[1, 2] <- x[13]
Sigma_new <- lambda %*% psi %*% t(lambda) + theta
LL <- lavaan:::lav_mvnorm_loglik_samplestats(
sample.mean = numeric(6),
sample.nobs = 301, # Use original sample size to get the correct loglikelihood
# sample.nobs = N_gks[g, k],
sample.cov  = (cov(Data) * 300) / 301, # Factor covariance matrix from step 1
Mu          = numeric(2),
Sigma       = Sigma_new # Factor covariance matrix from step 2
)
return(LL)
}
S1par <- coef(fit.MM, type = "free")
H_1 <- numDeriv::hessian(func = obj.S1, x = S1par)
# Second, replicate the Hessian of the parameters of Step 2 (NOT NECESSARY)
obj.S2 <- function(x){
beta <- matrix(data = 0, nrow = q, ncol = q)
beta[1, 2] <- x[1]
psi <- matrix(data = 0, nrow = q, ncol = q)
psi[1, 1] <- x[3]
psi[2, 2] <- x[2]
Sigma_new <- solve(I - beta) %*% psi %*% t(solve(I - beta))
LL <- lavaan:::lav_mvnorm_loglik_samplestats(
sample.mean = numeric(2),
sample.nobs = 301,
sample.cov  = (cov_S1 * 300) / 301,
Mu          = numeric(2),
Sigma       = Sigma_new
)
return(-1 * LL)
}
obj.S2(x = c(0.4215874, 0.9812431, 0.6475562))
I <- diag(q)
S2par <- coef(fit.SM, type = "free")
H_2 <- numDeriv::hessian(func = obj.S2, x = S2par)
H_2 <- numDeriv::hessian(func = obj.S2, x = c(0.4215874, 0.9812431, 0.6475562))
H_2 <- numDeriv::hessian(func = obj.S2, x = S2par)
H_2
H_2 <- numDeriv::hessian(func = obj.S2, x = c(0.4215874, 0.9812431, 0.6475562))
H_2
S2par
# Third, replicate C. Is it possible with numDeriv?
obj.comb <- function(x){
lambda <- matrix(data = 0, nrow = p, ncol = q)
lambda[1, 1] <- 1; lambda[4, 2] <- 1
lambda[2:3, 1] <- x[1:2]
lambda[5:6, 2] <- x[3:4]
theta <- matrix(data = 0, nrow = p, ncol = p)
diag(theta) <- x[5:10]
beta <- matrix(data = 0, nrow = q, ncol = q)
beta[1, 2] <- x[11]
psi <- matrix(data = 0, nrow = q, ncol = q)
psi[1, 1] <- x[12]
psi[2, 2] <- x[13]
Sigma_new <- lambda %*% solve(I - beta) %*% psi %*% t(solve(I - beta)) %*% t(lambda) + theta
LL <- lavaan:::lav_mvnorm_loglik_samplestats(
sample.mean = numeric(6),
sample.nobs = 301,
sample.cov  = (cov(Data) * 300) / 301,
Mu          = numeric(2),
Sigma       = Sigma_new
)
return(LL)
}
HESS <- numDeriv::hessian(func = obj.comb, x = c(S1par[1:10], 0.4215874, 0.6475562, 0.9812431))#S2par))
HESS
# Extract the individual parts of the matrix
I_11 <- -HESS[1:10, 1:10]
I_22 <- -HESS[11:13, 11:13]
I_21 <- -HESS[11:13, 1:10]
I_22
I_11
solve(I_11)
solve(I_11*301)
vcov()
vcov(fit.MM)
hess.MM
I_11*301
I_11
vcov(fit.MM)
solve(I_11)
solve(hess.MM)
I_11
hess.MM
round(I_11, 3)
I_11
# Extract the individual parts of the matrix
I_11 <- -HESS[c(1:10, 12:13), c(1:10, 12:13)]
I_22 <- -HESS[11:13, 11:13]
I_21 <- -HESS[11:13, c(1:10, 12:13)]
diag(round(sqrt(solve(I_22) + solve(I_22) %*% I_21 %*% solve(I_11)[1:10, 1:10] %*% t(I_21) %*% solve(I_22)), 3))
solve(I_22)
I_21
diag(round(sqrt(solve(I_22) + solve(I_22) %*% I_21 %*% solve(I_11) %*% t(I_21) %*% solve(I_22)), 3))
summary(fit)
# SAM model for reference ----------------------------------------------------------------------------------------------
Data <- HolzingerSwineford1939 %>% dplyr::select(x1:x6) %>% scale(x = ., center = T, scale = F)
HS.model <- '
visual  =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
visual ~ textual
'
fit <- sam(HS.model, data = Data,
mm.list = list(c("visual", "textual")),
information = "observed"
)
summary(fit)
fit@Fit@se
lavInspect(fit, "se")
diag(round(sqrt(solve(I_22) + solve(I_22) %*% I_21 %*% solve(I_11) %*% t(I_21) %*% solve(I_22)), 3))
# Third, replicate C. Is it possible with numDeriv?
obj.comb <- function(x){
lambda <- matrix(data = 0, nrow = p, ncol = q)
lambda[1, 1] <- 1; lambda[4, 2] <- 1
lambda[2:3, 1] <- x[1:2]
lambda[5:6, 2] <- x[3:4]
theta <- matrix(data = 0, nrow = p, ncol = p)
diag(theta) <- x[5:10]
beta <- matrix(data = 0, nrow = q, ncol = q)
beta[1, 2] <- x[11]
psi <- matrix(data = 0, nrow = q, ncol = q)
psi[1, 1] <- x[13]
psi[2, 2] <- x[12]
Sigma_new <- lambda %*% solve(I - beta) %*% psi %*% t(solve(I - beta)) %*% t(lambda) + theta
LL <- lavaan:::lav_mvnorm_loglik_samplestats(
sample.mean = numeric(6),
sample.nobs = 301,
sample.cov  = (cov(Data) * 300) / 301,
Mu          = numeric(2),
Sigma       = Sigma_new
)
return(LL)
}
HESS <- numDeriv::hessian(func = obj.comb, x = c(S1par[1:10], 0.4215874, 0.9812431, 0.6475562))#S2par))
# Extract the individual parts of the matrix
I_11 <- -HESS[c(1:10, 12:13), c(1:10, 12:13)]
I_22 <- -HESS[11:13, 11:13]
I_21 <- -HESS[11:13, c(1:10, 12:13)]
diag(round(sqrt(solve(I_22) + solve(I_22) %*% I_21 %*% solve(I_11) %*% t(I_21) %*% solve(I_22)), 3))
S2par
lavInspect(fit, "se") # To compare
diag(round(sqrt(solve(I_22) + solve(I_22) %*% I_21 %*% solve(I_11) %*% t(I_21) %*% solve(I_22)), 3))
S2par
HESS <- numDeriv::hessian(func = obj.comb, x = c(S1par[1:10], 0.4215874, 0.6475562, 0.9812431))#S2par))
# Extract the individual parts of the matrix
I_11 <- -HESS[c(1:10, 12:13), c(1:10, 12:13)]
I_22 <- -HESS[11:13, 11:13]
I_21 <- -HESS[11:13, c(1:10, 12:13)]
diag(round(sqrt(solve(I_22) + solve(I_22) %*% I_21 %*% solve(I_11) %*% t(I_21) %*% solve(I_22)), 3))
cov_S1
HESS <- numDeriv::hessian(func = obj.comb, x = c(S1par[1:10], 0.4215874, 0.9812431, 0.6475562))#S2par))
# Extract the individual parts of the matrix
I_11 <- -HESS[c(1:10, 12:13), c(1:10, 12:13)]
I_22 <- -HESS[11:13, 11:13]
I_21 <- -HESS[11:13, c(1:10, 12:13)]
diag(round(sqrt(solve(I_22) + solve(I_22) %*% I_21 %*% solve(I_11) %*% t(I_21) %*% solve(I_22)), 3))
lavInspect(fit, "se") # To compare
HESS <- numDeriv::hessian(func = obj.comb, x = c(S1par[1:10], S2par))
# Extract the individual parts of the matrix
I_11 <- -HESS[c(1:10, 12:13), c(1:10, 12:13)]
I_22 <- -HESS[11:13, 11:13]
I_21 <- -HESS[11:13, c(1:10, 12:13)]
diag(round(sqrt(solve(I_22) + solve(I_22) %*% I_21 %*% solve(I_11) %*% t(I_21) %*% solve(I_22)), 3))
S2par
unclass(S2par)
cov_S2
cov_S1
unclass(est_S1$psi)
vcov(fit.MM)
# Extract the individual parts of the matrix
I_11 <- -HESS[c(1:10, 12:13), c(1:10, 12:13)]; I_11[12:13, 12:13] <- 0
I_22 <- -HESS[11:13, 11:13]
# Extract the individual parts of the matrix
I_11 <- -HESS[c(1:10, 12:13), c(1:10, 12:13)]; I_11[11:12, 11:12] <- 0
I_22 <- -HESS[11:13, 11:13]
I_21 <- -HESS[11:13, c(1:10, 12:13)]
diag(round(sqrt(solve(I_22) + solve(I_22) %*% I_21 %*% solve(I_11) %*% t(I_21) %*% solve(I_22)), 3))
I_11
# Extract the individual parts of the matrix
I_11 <- -HESS[c(1:10, 12:13), c(1:10, 12:13)]; I_11[11:12, ] <- 0; I_11[, 11:12] <- 0
I_22 <- -HESS[11:13, 11:13]
I_21 <- -HESS[11:13, c(1:10, 12:13)]
diag(round(sqrt(solve(I_22) + solve(I_22) %*% I_21 %*% solve(I_11) %*% t(I_21) %*% solve(I_22)), 3))
# Extract the individual parts of the matrix
I_11 <- -HESS[c(1:10, 12:13), c(1:10, 12:13)]
# Extract the individual parts of the matrix
I_11 <- -HESS[c(1:10, 12:13), c(1:10, 12:13)]
I_11.inv <- solve(I_11)
# Extract the individual parts of the matrix
I_11 <- -HESS[c(1:10, 12:13), c(1:10, 12:13)]
I_11.inv <- solve(I_11); I_11.inv[11:12, ] <- 0; I_11.inv[, 11:12] <- 0
I_11.inv
diag(round(sqrt(solve(I_22) + solve(I_22) %*% I_21 %*% solve(I_11) %*% t(I_21) %*% solve(I_22)), 3))
vcovS1 <- vcov(fit.MM)
vcovS1
vcovS1 <- vcov(fit.MM)[-13, -13]; vcovS1[11:12, ] <- 0; vcovS1[, 11:12] <- 0
vcovS1
solve(I_11)
diag(round(sqrt(solve(I_22) + solve(I_22) %*% I_21 %*% I_11.inv %*% t(I_21) %*% solve(I_22)), 3))
I_11.inv
vcovS1
diag(round(sqrt(solve(I_22) + solve(I_22) %*% I_21 %*% vcovS1 %*% t(I_21) %*% solve(I_22)), 3))
lavInspect(fit, "se") # To compare
diag(round(sqrt(solve(I_22) + solve(I_22) %*% I_21 %*% vcovS1 %*% t(I_21) %*% solve(I_22)), 3)) # Freaking success
vcovS1
lavInspect(fit, "se") # To compare
diag(round(sqrt(solve(I_22) + solve(I_22) %*% I_21 %*% vcovS1 %*% t(I_21) %*% solve(I_22)), 3)) # Freaking success
HESS <- numDeriv::hessian(func = obj.comb, x = c(S1par[1:10], 0.4215874, 0.9812431, 0.6475562))#S2par))
# Extract the individual parts of the matrix
I_11 <- -HESS[c(1:10, 12:13), c(1:10, 12:13)]
I_11.inv <- solve(I_11); I_11.inv[11:12, ] <- 0; I_11.inv[, 11:12] <- 0
vcovS1 <- vcov(fit.MM)[-13, -13]; vcovS1[11:12, ] <- 0; vcovS1[, 11:12] <- 0
I_22 <- -HESS[11:13, 11:13]
I_21 <- -HESS[11:13, c(1:10, 12:13)]
# diag(round(sqrt(solve(I_22) + solve(I_22) %*% I_21 %*% I_11.inv %*% t(I_21) %*% solve(I_22)), 3))
diag(round(sqrt(solve(I_22) + solve(I_22) %*% I_21 %*% vcovS1 %*% t(I_21) %*% solve(I_22)), 3)) # Freaking success
lavInspect(fit, "se") # To compare
library(lavaan)
library(dplyr)
setwd("C:/Users/perezalo/Documents/GitHub/MMG-SEM")
source("MMG-SEM.R")
source("E_Step.R")
setwd("C:/Users/perezalo/Documents/GitHub/SE_sim")
source("DataGeneration.R")
# Define models
# Model Specification
model <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
MM <- '
# factor loadings
F1 =~ x1 + x2 + x3 + x4 + x5
F2 =~ z1 + z2 + z3 + z4 + z5
F3 =~ m1 + m2 + m3 + m4 + m5
F4 =~ y1 + y2 + y3 + y4 + y5
'
SM <- '
# Regression parameters
F4 ~ F1 + F3
F3 ~ F1 + F2
'
NonInv <- "F1 =~ x2"
# Generate data
# Simple model (12 groups, 2 clusters)
set.seed(1)
g <- 4
k <- 2
Data <- DataGeneration(model = model, nclus = k, ngroups = g, N_g = 100,
reg_coeff = 0.4, balance = "balanced", reliability = "high",
NonInvSize = 0.2, NonInvItems = 2, NonInvG = 0.5, NonInvType = "random",
ResRange = 0, randomVarX = T)$SimData
# Run MMGSEM
fit.MMGSEM <- MMGSEM(dat = Data, step1model = MM, step2model = SM, group = "group", nclus = k,
seed = 1, nstarts = 1, allG = T, NonInv = NonInv, fit = "factors",
est_method = "local", se = "standard")
# Run the wrapper
SE <- se(fit.MMGSEM)
setwd("C:/Users/perezalo/Documents/GitHub/MMG-SEM")
source("SE.R")
# Run the wrapper
SE <- se(fit.MMGSEM)
SE$SE_vector[SE$SE_vector %in% unlist(SE$betas_SE)]
# Generate data
# Simple model (12 groups, 2 clusters)
set.seed(1)
g <- 4
k <- 2
Data <- DataGeneration(model = model, nclus = k, ngroups = g, N_g = 100,
reg_coeff = 0.4, balance = "balanced", reliability = "high",
NonInvSize = 0.2, NonInvItems = 2, NonInvG = 0.5, NonInvType = "random",
ResRange = 0, randomVarX = T)$SimData
# Run MMGSEM
fit.MMGSEM <- MMGSEM(dat = Data, step1model = MM, step2model = SM, group = "group", nclus = k,
seed = 1, nstarts = 1, allG = T, NonInv = NonInv, fit = "factors",
est_method = "local", se = "standard")
round(fit.MMGSEM$z_gks, 2)
# Run the wrapper
SE <- se(fit.MMGSEM)
# Run the wrapper
system.time(SE <- se(fit.MMGSEM))
# Do the correction
vcov(fit.MMGSEM$MM)
# Do the correction
View(vcov(fit.MMGSEM$MM))
# Do the correction
round(sqrt(diag(View(vcov(fit.MMGSEM$MM)))), 3)
# Do the correction
round(sqrt(diag(vcov(fit.MMGSEM$MM))), 3)
View(SE)
View(se)
source("~/GitHub/MMG-SEM/SE.R", echo=TRUE)
# Run the wrapper
system.time(SE <- se(fit.MMGSEM))
SE
# Generate data
# Simple model (12 groups, 2 clusters)
set.seed(1)
g <- 12
k <- 2
Data <- DataGeneration(model = model, nclus = k, ngroups = g, N_g = 100,
reg_coeff = 0.4, balance = "balanced", reliability = "high",
NonInvSize = 0.2, NonInvItems = 2, NonInvG = 0.5, NonInvType = "random",
ResRange = 0, randomVarX = T)$SimData
# Run MMGSEM
fit.MMGSEM <- MMGSEM(dat = Data, step1model = MM, step2model = SM, group = "group", nclus = k,
seed = 1, nstarts = 1, allG = T, NonInv = NonInv, fit = "factors",
est_method = "local", se = "standard")
round(fit.MMGSEM$z_gks, 2)
# Run the wrapper
system.time(SE <- se(fit.MMGSEM))
462/60
SE$betas_SE
SE$SE_vector[SE$SE_vector %in% unlist(SE$betas_SE)]
SE$SE_vector[SE$SE_vector %in% unlist(SE$lambda_SE)]
# Generate data
# Simple model (12 groups, 2 clusters)
set.seed(1)
g <- 4
k <- 2
Data <- DataGeneration(model = model, nclus = k, ngroups = g, N_g = 100,
reg_coeff = 0.4, balance = "balanced", reliability = "high",
NonInvSize = 0.2, NonInvItems = 2, NonInvG = 0.5, NonInvType = "random",
ResRange = 0, randomVarX = T)$SimData
# Run MMGSEM
fit.MMGSEM <- MMGSEM(dat = Data, step1model = MM, step2model = SM, group = "group", nclus = k,
seed = 1, nstarts = 1, allG = T, NonInv = NonInv, fit = "factors",
est_method = "local", se = "standard")
round(fit.MMGSEM$z_gks, 2)
# Run the wrapper
system.time(SE <- se(fit.MMGSEM))
source("~/GitHub/MMG-SEM/SE.R", echo=TRUE)
# Run the wrapper
system.time(SE <- se(fit.MMGSEM))
source("~/GitHub/MMG-SEM/SE.R", echo=TRUE)
# Run the wrapper
system.time(SE <- se(fit.MMGSEM))
SE$SE_vector[SE$SE_vector %in% unlist(SE$betas_SE)]
SE$SE_vector[SE$SE$SE_vector %in% unlist(SE$SE$betas_SE)]
SE$SE$SE_vector
SE$SE$betas_SE
unlist(SE$SE$betas_SE)
SE$SE$SE_vector[SE$SE$SE_vector %in% unlist(SE$SE$betas_SE)]
SE$SE$SE_vector[SE$SE$SE_vector %in% unlist(SE$SE$lambda_SE)]
# Do the correction
SE$HESS
# Do the correction
View(SE$HESS)
vcov(fit.MMGSEM$MM)
lavInspect(fit.MMGSEM$MM, what = "hessian")
View(lavInspect(fit.MMGSEM$MM, what = "hessian"))
colnames(lavInspect(fit.MMGSEM$MM, what = "hessian"))
View(lavInspect(fit.MMGSEM$MM, what = "hessian"))
View(lavInspect(fit.MMGSEM$MM, what = "hessian")*301)
SE$SE$SE_vector[SE$SE$SE_vector %in% unlist(SE$SE$lambda_SE)]
sqrt(diag(vcov(fit.MMGSEM$MM)))
View(lavInspect(fit.MMGSEM$MM, what = "hessian")*400)
View(lavInspect(fit.MMGSEM$MM, what = "hessian")*800)
solve(vcov(fit.MMGSEM$MM))
View(vcov(fit.MMGSEM$MM))
source("~/GitHub/MMG-SEM/SE.R", echo=TRUE)
set.seed(1)
g <- 4
k <- 2
Data <- DataGeneration(model = model, nclus = k, ngroups = g, N_g = 100,
reg_coeff = 0.4, balance = "balanced", reliability = "high",
NonInvSize = 0.2, NonInvItems = 2, NonInvG = 0.5, NonInvType = "random",
ResRange = 0, randomVarX = T)$SimData
# Run MMGSEM
fit.MMGSEM <- MMGSEM(dat = Data, step1model = MM, step2model = SM, group = "group", nclus = k,
seed = 1, nstarts = 1, allG = T, NonInv = NonInv, fit = "factors",
est_method = "local", se = "standard")
round(fit.MMGSEM$z_gks, 2)
# Run the wrapper
system.time(SE <- se(fit.MMGSEM))
SE$SE$SE_vector[SE$SE$SE_vector %in% unlist(SE$SE$betas_SE)]
SE$SE$SE_vector[SE$SE$SE_vector %in% unlist(SE$SE$lambda_SE)]
lambda_SE
SE$SE$lambda_SE
unlist(SE$SE$lambda_SE)
SE$SE$SE_vector %in% unlist(SE$SE$lambda_SE)
SE$SE$SE_vector
source("~/GitHub/MMG-SEM/SE.R", echo=TRUE)
# Run the wrapper
system.time(SE <- se(fit.MMGSEM))
SE$SE$SE_vector[SE$SE$SE_vector %in% unlist(SE$SE$lambda_SE)]
source("~/GitHub/MMG-SEM/SE.R", echo=TRUE)
# Run the wrapper
system.time(SE <- se(fit.MMGSEM))
SE$SE$SE_vector[SE$SE$SE_vector %in% unlist(SE$SE$lambda_SE)]
fit.MMGSEM$MM
summary(fit.MMGSEM$MM)
head(vcov(fit.MMGSEM$MM))
source("~/GitHub/MMG-SEM/SE.R", echo=TRUE)
# Run the wrapper
system.time(SE <- se(fit.MMGSEM))
Sigma_1
Sigma_1[, !duplicated(colnames(Simga_1))]
source("~/GitHub/MMG-SEM/SE.R", echo=TRUE)
# Run the wrapper
system.time(SE <- se(fit.MMGSEM))
duplicated(colnames(Sigma_1)
)
!duplicated(colnames(Sigma_1))
grepl(pattern = ".p", x = colnames(Sigma_1))
names(cons_vec)
Sigma_1
Sigma_1[, c(names(cons_vec), names(unco_vec), names(theta_vec))]
source("~/GitHub/MMG-SEM/SE.R", echo=TRUE)
# Run the wrapper
system.time(SE <- se(fit.MMGSEM))
colnames(Sigma_1)[grep(pattern = ".g", x = colnames(Sigma_1))]
colnames(Sigma_1)[grep(pattern = ".g", x = colnames(Sigma_1), invert = T)]
colnames(Sigma_1)[grepl(pattern = ".p", x = colnames(Sigma_1))]
colnames(Sigma_1)[grepl(pattern = ".g2", x = colnames(Sigma_1))]
colnames(Sigma_1)[grep(pattern = ".g2", x = colnames(Sigma_1))]
grep(pattern = ".g2", x = colnames(Sigma_1))
grepl(pattern = ".g2", x = colnames(Sigma_1))
source("~/GitHub/MMG-SEM/SE.R", echo=TRUE)
# Run the wrapper
system.time(SE <- se(fit.MMGSEM))
Sigma_1
Sigma_1[, c(names(cons_vec), names(unco_vec), names(theta_vec))]
source("~/GitHub/MMG-SEM/SE.R", echo=TRUE)
# Run the wrapper
system.time(SE <- se(fit.MMGSEM))
traceback
traceback()
source("~/GitHub/MMG-SEM/SE.R", echo=TRUE)
source("~/GitHub/MMG-SEM/SE.R", echo=TRUE)
# Run the wrapper
system.time(SE <- se(fit.MMGSEM))
step1.idx
step2.idx
Sigma_1
Sigma_1[step1.idx, step1.idx]
(ViewSigma_1[step1.idx, step1.idx])
View(Sigma_1[step1.idx, step1.idx])
diag(Sigma_1[step1.idx, step1.idx)
diag(Sigma_1[step1.idx, step1.idx])
source("~/GitHub/MMG-SEM/SE.R", echo=TRUE)
# Run the wrapper
system.time(SE <- se(fit.MMGSEM))
source("~/GitHub/MMG-SEM/SE.R", echo=TRUE)
# Run the wrapper
system.time(SE <- se(fit.MMGSEM))
rownames(Sigma_1)
source("~/GitHub/MMG-SEM/SE.R", echo=TRUE)
# Run the wrapper
system.time(SE <- se(fit.MMGSEM))
Sigma_1
Vire(Sigma_1[step1.idx, step1.idx])
View(Sigma_1[step1.idx, step1.idx])
source("~/GitHub/MMG-SEM/SE.R", echo=TRUE)
